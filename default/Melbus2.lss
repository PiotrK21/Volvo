
Melbus2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000080  00800060  000009c2  00000a56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  008000e0  008000e0  00000ad6  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00000ad6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001da  00000000  00000000  00000af6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000053e  00000000  00000000  00000cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000017a  00000000  00000000  0000120e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000055c  00000000  00000000  00001388  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000b0  00000000  00000000  000018e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001f5  00000000  00000000  00001994  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 7d 04 	jmp	0x8fa	; 0x8fa <__vector_1>
   8:	0c 94 87 04 	jmp	0x90e	; 0x90e <__vector_2>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 2c 04 	jmp	0x858	; 0x858 <__vector_5>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 9a 00 	jmp	0x134	; 0x134 <__vector_8>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 ec       	ldi	r30, 0xC2	; 194
  68:	f9 e0       	ldi	r31, 0x09	; 9
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a0 3e       	cpi	r26, 0xE0	; 224
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a0 ee       	ldi	r26, 0xE0	; 224
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	aa 3e       	cpi	r26, 0xEA	; 234
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 b8 04 	call	0x970	; 0x970 <main>
  8a:	0c 94 df 04 	jmp	0x9be	; 0x9be <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <init_extint0>:
volatile unsigned int mDataBuff[7] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};


void init_extint0(void)
{
	GICR |= 1<<INT0; 	// Enable INT0 External Interrupt
  92:	8b b7       	in	r24, 0x3b	; 59
  94:	80 64       	ori	r24, 0x40	; 64
  96:	8b bf       	out	0x3b, r24	; 59
	MCUCR |= 1<<ISC01; 	// Falling-Edge Triggered INT0
  98:	85 b7       	in	r24, 0x35	; 53
  9a:	82 60       	ori	r24, 0x02	; 2
  9c:	85 bf       	out	0x35, r24	; 53
}
  9e:	08 95       	ret

000000a0 <init_extint1>:


void init_extint1(void)
{
	GICR |= 1<<INT1; // Enable INT1 External Interrupt
  a0:	8b b7       	in	r24, 0x3b	; 59
  a2:	80 68       	ori	r24, 0x80	; 128
  a4:	8b bf       	out	0x3b, r24	; 59
	MCUCR |= 1<<ISC11; // Falling-Edge Triggered INT0
  a6:	85 b7       	in	r24, 0x35	; 53
  a8:	88 60       	ori	r24, 0x08	; 8
  aa:	85 bf       	out	0x35, r24	; 53
}
  ac:	08 95       	ret

000000ae <init_timer>:

void init_timer(void)
{
	TIMSK|=(1<<TICIE1)|(1<<TOIE1);  // T1 Interrupt Capture and Timer1 Overflow
  ae:	89 b7       	in	r24, 0x39	; 57
  b0:	84 62       	ori	r24, 0x24	; 36
  b2:	89 bf       	out	0x39, r24	; 57
 	TCCR1B|=(1<<ICES1); 	// Rising-Edge Triggered
  b4:	8e b5       	in	r24, 0x2e	; 46
  b6:	80 64       	ori	r24, 0x40	; 64
  b8:	8e bd       	out	0x2e, r24	; 46
}
  ba:	08 95       	ret

000000bc <setoutput_mdata>:

void setoutput_mdata(void)
{
	DDRD |= (1<<PIND2); // PD2 output
  bc:	8a 9a       	sbi	0x11, 2	; 17
	PORTD |= (1 << PD2);
  be:	92 9a       	sbi	0x12, 2	; 18
}
  c0:	08 95       	ret

000000c2 <mPopulateBuffer>:

void mPopulateBuffer(void) // circular buffer? yeah, it works
{
	mDataBuff[0]=mDataBuff[1]; 
  c2:	80 91 d4 00 	lds	r24, 0x00D4
  c6:	90 91 d5 00 	lds	r25, 0x00D5
  ca:	90 93 d3 00 	sts	0x00D3, r25
  ce:	80 93 d2 00 	sts	0x00D2, r24
	mDataBuff[1]=mDataBuff[2];
  d2:	80 91 d6 00 	lds	r24, 0x00D6
  d6:	90 91 d7 00 	lds	r25, 0x00D7
  da:	90 93 d5 00 	sts	0x00D5, r25
  de:	80 93 d4 00 	sts	0x00D4, r24
	mDataBuff[2]=mDataBuff[3];
  e2:	80 91 d8 00 	lds	r24, 0x00D8
  e6:	90 91 d9 00 	lds	r25, 0x00D9
  ea:	90 93 d7 00 	sts	0x00D7, r25
  ee:	80 93 d6 00 	sts	0x00D6, r24
	mDataBuff[3]=mDataBuff[4];
  f2:	80 91 da 00 	lds	r24, 0x00DA
  f6:	90 91 db 00 	lds	r25, 0x00DB
  fa:	90 93 d9 00 	sts	0x00D9, r25
  fe:	80 93 d8 00 	sts	0x00D8, r24
	mDataBuff[4]=mDataBuff[5];
 102:	80 91 dc 00 	lds	r24, 0x00DC
 106:	90 91 dd 00 	lds	r25, 0x00DD
 10a:	90 93 db 00 	sts	0x00DB, r25
 10e:	80 93 da 00 	sts	0x00DA, r24
	mDataBuff[5]=mDataBuff[6];
 112:	80 91 de 00 	lds	r24, 0x00DE
 116:	90 91 df 00 	lds	r25, 0x00DF
 11a:	90 93 dd 00 	sts	0x00DD, r25
 11e:	80 93 dc 00 	sts	0x00DC, r24
	mDataBuff[6]=mDataIn; 
 122:	80 91 e0 00 	lds	r24, 0x00E0
 126:	90 91 e1 00 	lds	r25, 0x00E1
 12a:	90 93 df 00 	sts	0x00DF, r25
 12e:	80 93 de 00 	sts	0x00DE, r24
}
 132:	08 95       	ret

00000134 <__vector_8>:

//overflow counter isr 
ISR(TIMER1_OVF_vect)
{
 134:	1f 92       	push	r1
 136:	0f 92       	push	r0
 138:	0f b6       	in	r0, 0x3f	; 63
 13a:	0f 92       	push	r0
 13c:	11 24       	eor	r1, r1
 13e:	2f 93       	push	r18
 140:	3f 93       	push	r19
 142:	4f 93       	push	r20
 144:	5f 93       	push	r21
 146:	8f 93       	push	r24
 148:	9f 93       	push	r25
 14a:	ef 93       	push	r30
 14c:	ff 93       	push	r31
	mClock=7; // reset bit counter
 14e:	87 e0       	ldi	r24, 0x07	; 7
 150:	90 e0       	ldi	r25, 0x00	; 0
 152:	90 93 d1 00 	sts	0x00D1, r25
 156:	80 93 d0 00 	sts	0x00D0, r24

	TCCR1B&=~(1<<CS11); // stop timer
 15a:	8e b5       	in	r24, 0x2e	; 46
 15c:	8d 7f       	andi	r24, 0xFD	; 253
 15e:	8e bd       	out	0x2e, r24	; 46

	if (mState == mState_SEND) // if SEND state relase DATA line
 160:	80 91 e6 00 	lds	r24, 0x00E6
 164:	90 91 e7 00 	lds	r25, 0x00E7
 168:	01 97       	sbiw	r24, 0x01	; 1
 16a:	31 f4       	brne	.+12     	; 0x178 <__vector_8+0x44>
	{
		mState = mState_REC;
 16c:	10 92 e7 00 	sts	0x00E7, r1
 170:	10 92 e6 00 	sts	0x00E6, r1
		DDRD &= ~(1<<PIND2); // input
 174:	8a 98       	cbi	0x11, 2	; 17
		PORTD |= (1<<PD2); // enable pull-up
 176:	92 9a       	sbi	0x12, 2	; 18
	PORTD |= (1 << PD2);
}

void mPopulateBuffer(void) // circular buffer? yeah, it works
{
	mDataBuff[0]=mDataBuff[1]; 
 178:	80 91 d4 00 	lds	r24, 0x00D4
 17c:	90 91 d5 00 	lds	r25, 0x00D5
 180:	90 93 d3 00 	sts	0x00D3, r25
 184:	80 93 d2 00 	sts	0x00D2, r24
	mDataBuff[1]=mDataBuff[2];
 188:	80 91 d6 00 	lds	r24, 0x00D6
 18c:	90 91 d7 00 	lds	r25, 0x00D7
 190:	90 93 d5 00 	sts	0x00D5, r25
 194:	80 93 d4 00 	sts	0x00D4, r24
	mDataBuff[2]=mDataBuff[3];
 198:	80 91 d8 00 	lds	r24, 0x00D8
 19c:	90 91 d9 00 	lds	r25, 0x00D9
 1a0:	90 93 d7 00 	sts	0x00D7, r25
 1a4:	80 93 d6 00 	sts	0x00D6, r24
	mDataBuff[3]=mDataBuff[4];
 1a8:	80 91 da 00 	lds	r24, 0x00DA
 1ac:	90 91 db 00 	lds	r25, 0x00DB
 1b0:	90 93 d9 00 	sts	0x00D9, r25
 1b4:	80 93 d8 00 	sts	0x00D8, r24
	mDataBuff[4]=mDataBuff[5];
 1b8:	80 91 dc 00 	lds	r24, 0x00DC
 1bc:	90 91 dd 00 	lds	r25, 0x00DD
 1c0:	90 93 db 00 	sts	0x00DB, r25
 1c4:	80 93 da 00 	sts	0x00DA, r24
	mDataBuff[5]=mDataBuff[6];
 1c8:	80 91 de 00 	lds	r24, 0x00DE
 1cc:	90 91 df 00 	lds	r25, 0x00DF
 1d0:	90 93 dd 00 	sts	0x00DD, r25
 1d4:	80 93 dc 00 	sts	0x00DC, r24
	mDataBuff[6]=mDataIn; 
 1d8:	80 91 e0 00 	lds	r24, 0x00E0
 1dc:	90 91 e1 00 	lds	r25, 0x00E1
 1e0:	90 93 df 00 	sts	0x00DF, r25
 1e4:	80 93 de 00 	sts	0x00DE, r24
		PORTD |= (1<<PD2); // enable pull-up
	} 

	mPopulateBuffer(); // populate circular buffer

	switch (mCmdFound)
 1e8:	80 91 e8 00 	lds	r24, 0x00E8
 1ec:	90 91 e9 00 	lds	r25, 0x00E9
 1f0:	89 2b       	or	r24, r25
 1f2:	09 f0       	breq	.+2      	; 0x1f6 <__vector_8+0xc2>
 1f4:	09 c2       	rjmp	.+1042   	; 0x608 <__stack+0x1a9>
	{
		case (mWaiting): // Are we waiting for Melbus Command? 
			

			// main Melbus init
			if ((mDataBuff[4]==mInit[0])&&(mDataBuff[5]==mInit[1])&&(mDataBuff[6]==mInit[2]))
 1f6:	20 91 da 00 	lds	r18, 0x00DA
 1fa:	30 91 db 00 	lds	r19, 0x00DB
 1fe:	80 91 60 00 	lds	r24, 0x0060
 202:	90 91 61 00 	lds	r25, 0x0061
 206:	28 17       	cp	r18, r24
 208:	39 07       	cpc	r19, r25
 20a:	b1 f4       	brne	.+44     	; 0x238 <__vector_8+0x104>
 20c:	20 91 dc 00 	lds	r18, 0x00DC
 210:	30 91 dd 00 	lds	r19, 0x00DD
 214:	80 91 62 00 	lds	r24, 0x0062
 218:	90 91 63 00 	lds	r25, 0x0063
 21c:	28 17       	cp	r18, r24
 21e:	39 07       	cpc	r19, r25
 220:	59 f4       	brne	.+22     	; 0x238 <__vector_8+0x104>
 222:	20 91 de 00 	lds	r18, 0x00DE
 226:	30 91 df 00 	lds	r19, 0x00DF
 22a:	80 91 64 00 	lds	r24, 0x0064
 22e:	90 91 65 00 	lds	r25, 0x0065
 232:	28 17       	cp	r18, r24
 234:	39 07       	cpc	r19, r25
 236:	09 f1       	breq	.+66     	; 0x27a <__vector_8+0x146>
				mCmdFound = mMelCmdInit;
			else

			// secondary init
			if ((mDataBuff[4]==mInitIgn[0])&&(mDataBuff[5]==mInitIgn[1])&&(mDataBuff[6]==mInitIgn[2]))
 238:	20 91 da 00 	lds	r18, 0x00DA
 23c:	30 91 db 00 	lds	r19, 0x00DB
 240:	80 91 66 00 	lds	r24, 0x0066
 244:	90 91 67 00 	lds	r25, 0x0067
 248:	28 17       	cp	r18, r24
 24a:	39 07       	cpc	r19, r25
 24c:	c9 f4       	brne	.+50     	; 0x280 <__vector_8+0x14c>
 24e:	20 91 dc 00 	lds	r18, 0x00DC
 252:	30 91 dd 00 	lds	r19, 0x00DD
 256:	80 91 68 00 	lds	r24, 0x0068
 25a:	90 91 69 00 	lds	r25, 0x0069
 25e:	28 17       	cp	r18, r24
 260:	39 07       	cpc	r19, r25
 262:	71 f4       	brne	.+28     	; 0x280 <__vector_8+0x14c>
 264:	20 91 de 00 	lds	r18, 0x00DE
 268:	30 91 df 00 	lds	r19, 0x00DF
 26c:	80 91 6a 00 	lds	r24, 0x006A
 270:	90 91 6b 00 	lds	r25, 0x006B
 274:	28 17       	cp	r18, r24
 276:	39 07       	cpc	r19, r25
 278:	19 f4       	brne	.+6      	; 0x280 <__vector_8+0x14c>
				mCmdFound = mMelCmdInit;
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	c0 c1       	rjmp	.+896    	; 0x600 <__stack+0x1a1>
			else


				// CDC
				if ((mDataBuff[2]==(mInitDeviceID[0]+1))&&(mDataBuff[3]==mPlay[0])&&(mDataBuff[4]==mPlay[1])&&(mDataBuff[5]==mPlay[2])&&(mDataBuff[6]==mPlay[3]))
 280:	20 91 d6 00 	lds	r18, 0x00D6
 284:	30 91 d7 00 	lds	r19, 0x00D7
 288:	80 91 c0 00 	lds	r24, 0x00C0
 28c:	90 91 c1 00 	lds	r25, 0x00C1
 290:	01 96       	adiw	r24, 0x01	; 1
 292:	28 17       	cp	r18, r24
 294:	39 07       	cpc	r19, r25
 296:	79 f5       	brne	.+94     	; 0x2f6 <__vector_8+0x1c2>
 298:	20 91 d8 00 	lds	r18, 0x00D8
 29c:	30 91 d9 00 	lds	r19, 0x00D9
 2a0:	80 91 72 00 	lds	r24, 0x0072
 2a4:	90 91 73 00 	lds	r25, 0x0073
 2a8:	28 17       	cp	r18, r24
 2aa:	39 07       	cpc	r19, r25
 2ac:	21 f5       	brne	.+72     	; 0x2f6 <__vector_8+0x1c2>
 2ae:	20 91 da 00 	lds	r18, 0x00DA
 2b2:	30 91 db 00 	lds	r19, 0x00DB
 2b6:	80 91 74 00 	lds	r24, 0x0074
 2ba:	90 91 75 00 	lds	r25, 0x0075
 2be:	28 17       	cp	r18, r24
 2c0:	39 07       	cpc	r19, r25
 2c2:	c9 f4       	brne	.+50     	; 0x2f6 <__vector_8+0x1c2>
 2c4:	20 91 dc 00 	lds	r18, 0x00DC
 2c8:	30 91 dd 00 	lds	r19, 0x00DD
 2cc:	80 91 76 00 	lds	r24, 0x0076
 2d0:	90 91 77 00 	lds	r25, 0x0077
 2d4:	28 17       	cp	r18, r24
 2d6:	39 07       	cpc	r19, r25
 2d8:	71 f4       	brne	.+28     	; 0x2f6 <__vector_8+0x1c2>
 2da:	20 91 de 00 	lds	r18, 0x00DE
 2de:	30 91 df 00 	lds	r19, 0x00DF
 2e2:	80 91 78 00 	lds	r24, 0x0078
 2e6:	90 91 79 00 	lds	r25, 0x0079
 2ea:	28 17       	cp	r18, r24
 2ec:	39 07       	cpc	r19, r25
 2ee:	19 f4       	brne	.+6      	; 0x2f6 <__vector_8+0x1c2>
					mCmdFound = mMelCmdPlay; 
 2f0:	82 e0       	ldi	r24, 0x02	; 2
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	85 c1       	rjmp	.+778    	; 0x600 <__stack+0x1a1>
				else

				// cd-c/md-c cartridge info request
				if ((mDataBuff[4]==mInitDeviceID[0])&&(mDataBuff[5]==mInfo[0])&&(mDataBuff[6]==mInfo[1]))
 2f6:	20 91 da 00 	lds	r18, 0x00DA
 2fa:	30 91 db 00 	lds	r19, 0x00DB
 2fe:	80 91 c0 00 	lds	r24, 0x00C0
 302:	90 91 c1 00 	lds	r25, 0x00C1
 306:	28 17       	cp	r18, r24
 308:	39 07       	cpc	r19, r25
 30a:	c9 f4       	brne	.+50     	; 0x33e <__vector_8+0x20a>
 30c:	20 91 dc 00 	lds	r18, 0x00DC
 310:	30 91 dd 00 	lds	r19, 0x00DD
 314:	80 91 7c 00 	lds	r24, 0x007C
 318:	90 91 7d 00 	lds	r25, 0x007D
 31c:	28 17       	cp	r18, r24
 31e:	39 07       	cpc	r19, r25
 320:	71 f4       	brne	.+28     	; 0x33e <__vector_8+0x20a>
 322:	20 91 de 00 	lds	r18, 0x00DE
 326:	30 91 df 00 	lds	r19, 0x00DF
 32a:	80 91 7e 00 	lds	r24, 0x007E
 32e:	90 91 7f 00 	lds	r25, 0x007F
 332:	28 17       	cp	r18, r24
 334:	39 07       	cpc	r19, r25
 336:	19 f4       	brne	.+6      	; 0x33e <__vector_8+0x20a>
					mCmdFound = mMelCmdInfo;
 338:	83 e0       	ldi	r24, 0x03	; 3
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	61 c1       	rjmp	.+706    	; 0x600 <__stack+0x1a1>
				else

				// powerdown or stop playing request!
				if ((mDataBuff[4]==mInitDeviceID[0])&&(mDataBuff[5]==mPwrDown[0])&&(mDataBuff[6]==mPwrDown[1]))
 33e:	20 91 da 00 	lds	r18, 0x00DA
 342:	30 91 db 00 	lds	r19, 0x00DB
 346:	80 91 c0 00 	lds	r24, 0x00C0
 34a:	90 91 c1 00 	lds	r25, 0x00C1
 34e:	28 17       	cp	r18, r24
 350:	39 07       	cpc	r19, r25
 352:	c9 f4       	brne	.+50     	; 0x386 <__vector_8+0x252>
 354:	20 91 dc 00 	lds	r18, 0x00DC
 358:	30 91 dd 00 	lds	r19, 0x00DD
 35c:	80 91 80 00 	lds	r24, 0x0080
 360:	90 91 81 00 	lds	r25, 0x0081
 364:	28 17       	cp	r18, r24
 366:	39 07       	cpc	r19, r25
 368:	71 f4       	brne	.+28     	; 0x386 <__vector_8+0x252>
 36a:	20 91 de 00 	lds	r18, 0x00DE
 36e:	30 91 df 00 	lds	r19, 0x00DF
 372:	80 91 82 00 	lds	r24, 0x0082
 376:	90 91 83 00 	lds	r25, 0x0083
 37a:	28 17       	cp	r18, r24
 37c:	39 07       	cpc	r19, r25
 37e:	19 f4       	brne	.+6      	; 0x386 <__vector_8+0x252>
					mCmdFound = mMelCmdPwrD;
 380:	85 e0       	ldi	r24, 0x05	; 5
 382:	90 e0       	ldi	r25, 0x00	; 0
 384:	3d c1       	rjmp	.+634    	; 0x600 <__stack+0x1a1>
				else

				/* buttons */
				if ((mDataBuff[2]==mInitDeviceID[0])&&(mDataBuff[3]==mNEXT[0])&&(mDataBuff[4]==mNEXT[1])&&(mDataBuff[5]==mNEXT[2])&&(mDataBuff[6]==mNEXT[3]))
 386:	20 91 d6 00 	lds	r18, 0x00D6
 38a:	30 91 d7 00 	lds	r19, 0x00D7
 38e:	80 91 c0 00 	lds	r24, 0x00C0
 392:	90 91 c1 00 	lds	r25, 0x00C1
 396:	28 17       	cp	r18, r24
 398:	39 07       	cpc	r19, r25
 39a:	79 f5       	brne	.+94     	; 0x3fa <__vector_8+0x2c6>
 39c:	20 91 d8 00 	lds	r18, 0x00D8
 3a0:	30 91 d9 00 	lds	r19, 0x00D9
 3a4:	80 91 84 00 	lds	r24, 0x0084
 3a8:	90 91 85 00 	lds	r25, 0x0085
 3ac:	28 17       	cp	r18, r24
 3ae:	39 07       	cpc	r19, r25
 3b0:	21 f5       	brne	.+72     	; 0x3fa <__vector_8+0x2c6>
 3b2:	20 91 da 00 	lds	r18, 0x00DA
 3b6:	30 91 db 00 	lds	r19, 0x00DB
 3ba:	80 91 86 00 	lds	r24, 0x0086
 3be:	90 91 87 00 	lds	r25, 0x0087
 3c2:	28 17       	cp	r18, r24
 3c4:	39 07       	cpc	r19, r25
 3c6:	c9 f4       	brne	.+50     	; 0x3fa <__vector_8+0x2c6>
 3c8:	20 91 dc 00 	lds	r18, 0x00DC
 3cc:	30 91 dd 00 	lds	r19, 0x00DD
 3d0:	80 91 88 00 	lds	r24, 0x0088
 3d4:	90 91 89 00 	lds	r25, 0x0089
 3d8:	28 17       	cp	r18, r24
 3da:	39 07       	cpc	r19, r25
 3dc:	71 f4       	brne	.+28     	; 0x3fa <__vector_8+0x2c6>
 3de:	20 91 de 00 	lds	r18, 0x00DE
 3e2:	30 91 df 00 	lds	r19, 0x00DF
 3e6:	80 91 8a 00 	lds	r24, 0x008A
 3ea:	90 91 8b 00 	lds	r25, 0x008B
 3ee:	28 17       	cp	r18, r24
 3f0:	39 07       	cpc	r19, r25
 3f2:	19 f4       	brne	.+6      	; 0x3fa <__vector_8+0x2c6>
					mCmdFound = mMelCmdNext;
 3f4:	86 e0       	ldi	r24, 0x06	; 6
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	03 c1       	rjmp	.+518    	; 0x600 <__stack+0x1a1>
				else
				if ((mDataBuff[2]==mInitDeviceID[0])&&(mDataBuff[3]==mPREV[0])&&(mDataBuff[4]==mPREV[1])&&(mDataBuff[5]==mPREV[2])&&(mDataBuff[6]==mPREV[3]))
 3fa:	20 91 d6 00 	lds	r18, 0x00D6
 3fe:	30 91 d7 00 	lds	r19, 0x00D7
 402:	80 91 c0 00 	lds	r24, 0x00C0
 406:	90 91 c1 00 	lds	r25, 0x00C1
 40a:	28 17       	cp	r18, r24
 40c:	39 07       	cpc	r19, r25
 40e:	79 f5       	brne	.+94     	; 0x46e <__stack+0xf>
 410:	20 91 d8 00 	lds	r18, 0x00D8
 414:	30 91 d9 00 	lds	r19, 0x00D9
 418:	80 91 8c 00 	lds	r24, 0x008C
 41c:	90 91 8d 00 	lds	r25, 0x008D
 420:	28 17       	cp	r18, r24
 422:	39 07       	cpc	r19, r25
 424:	21 f5       	brne	.+72     	; 0x46e <__stack+0xf>
 426:	20 91 da 00 	lds	r18, 0x00DA
 42a:	30 91 db 00 	lds	r19, 0x00DB
 42e:	80 91 8e 00 	lds	r24, 0x008E
 432:	90 91 8f 00 	lds	r25, 0x008F
 436:	28 17       	cp	r18, r24
 438:	39 07       	cpc	r19, r25
 43a:	c9 f4       	brne	.+50     	; 0x46e <__stack+0xf>
 43c:	20 91 dc 00 	lds	r18, 0x00DC
 440:	30 91 dd 00 	lds	r19, 0x00DD
 444:	80 91 90 00 	lds	r24, 0x0090
 448:	90 91 91 00 	lds	r25, 0x0091
 44c:	28 17       	cp	r18, r24
 44e:	39 07       	cpc	r19, r25
 450:	71 f4       	brne	.+28     	; 0x46e <__stack+0xf>
 452:	20 91 de 00 	lds	r18, 0x00DE
 456:	30 91 df 00 	lds	r19, 0x00DF
 45a:	80 91 92 00 	lds	r24, 0x0092
 45e:	90 91 93 00 	lds	r25, 0x0093
 462:	28 17       	cp	r18, r24
 464:	39 07       	cpc	r19, r25
 466:	19 f4       	brne	.+6      	; 0x46e <__stack+0xf>
					mCmdFound = mMelCmdPrev; 
 468:	87 e0       	ldi	r24, 0x07	; 7
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	c9 c0       	rjmp	.+402    	; 0x600 <__stack+0x1a1>
				else
				if ((mDataBuff[3]==mInitDeviceID[0])&&(mDataBuff[4]==mDINC[0])&&(mDataBuff[5]==mDINC[1])&&(mDataBuff[6]==mDINC[2]))
 46e:	20 91 d8 00 	lds	r18, 0x00D8
 472:	30 91 d9 00 	lds	r19, 0x00D9
 476:	80 91 c0 00 	lds	r24, 0x00C0
 47a:	90 91 c1 00 	lds	r25, 0x00C1
 47e:	28 17       	cp	r18, r24
 480:	39 07       	cpc	r19, r25
 482:	21 f5       	brne	.+72     	; 0x4cc <__stack+0x6d>
 484:	20 91 da 00 	lds	r18, 0x00DA
 488:	30 91 db 00 	lds	r19, 0x00DB
 48c:	80 91 94 00 	lds	r24, 0x0094
 490:	90 91 95 00 	lds	r25, 0x0095
 494:	28 17       	cp	r18, r24
 496:	39 07       	cpc	r19, r25
 498:	c9 f4       	brne	.+50     	; 0x4cc <__stack+0x6d>
 49a:	20 91 dc 00 	lds	r18, 0x00DC
 49e:	30 91 dd 00 	lds	r19, 0x00DD
 4a2:	80 91 96 00 	lds	r24, 0x0096
 4a6:	90 91 97 00 	lds	r25, 0x0097
 4aa:	28 17       	cp	r18, r24
 4ac:	39 07       	cpc	r19, r25
 4ae:	71 f4       	brne	.+28     	; 0x4cc <__stack+0x6d>
 4b0:	20 91 de 00 	lds	r18, 0x00DE
 4b4:	30 91 df 00 	lds	r19, 0x00DF
 4b8:	80 91 98 00 	lds	r24, 0x0098
 4bc:	90 91 99 00 	lds	r25, 0x0099
 4c0:	28 17       	cp	r18, r24
 4c2:	39 07       	cpc	r19, r25
 4c4:	19 f4       	brne	.+6      	; 0x4cc <__stack+0x6d>
					mCmdFound = mMelCmdDinc; 
 4c6:	88 e0       	ldi	r24, 0x08	; 8
 4c8:	90 e0       	ldi	r25, 0x00	; 0
 4ca:	9a c0       	rjmp	.+308    	; 0x600 <__stack+0x1a1>
				else
				if ((mDataBuff[3]==mInitDeviceID[0])&&(mDataBuff[4]==mDDEC[0])&&(mDataBuff[5]==mDDEC[1])&&(mDataBuff[6]==mDDEC[2]))
 4cc:	20 91 d8 00 	lds	r18, 0x00D8
 4d0:	30 91 d9 00 	lds	r19, 0x00D9
 4d4:	80 91 c0 00 	lds	r24, 0x00C0
 4d8:	90 91 c1 00 	lds	r25, 0x00C1
 4dc:	28 17       	cp	r18, r24
 4de:	39 07       	cpc	r19, r25
 4e0:	21 f5       	brne	.+72     	; 0x52a <__stack+0xcb>
 4e2:	20 91 da 00 	lds	r18, 0x00DA
 4e6:	30 91 db 00 	lds	r19, 0x00DB
 4ea:	80 91 9a 00 	lds	r24, 0x009A
 4ee:	90 91 9b 00 	lds	r25, 0x009B
 4f2:	28 17       	cp	r18, r24
 4f4:	39 07       	cpc	r19, r25
 4f6:	c9 f4       	brne	.+50     	; 0x52a <__stack+0xcb>
 4f8:	20 91 dc 00 	lds	r18, 0x00DC
 4fc:	30 91 dd 00 	lds	r19, 0x00DD
 500:	80 91 9c 00 	lds	r24, 0x009C
 504:	90 91 9d 00 	lds	r25, 0x009D
 508:	28 17       	cp	r18, r24
 50a:	39 07       	cpc	r19, r25
 50c:	71 f4       	brne	.+28     	; 0x52a <__stack+0xcb>
 50e:	20 91 de 00 	lds	r18, 0x00DE
 512:	30 91 df 00 	lds	r19, 0x00DF
 516:	80 91 9e 00 	lds	r24, 0x009E
 51a:	90 91 9f 00 	lds	r25, 0x009F
 51e:	28 17       	cp	r18, r24
 520:	39 07       	cpc	r19, r25
 522:	19 f4       	brne	.+6      	; 0x52a <__stack+0xcb>
					mCmdFound = mMelCmdDdec; 
 524:	89 e0       	ldi	r24, 0x09	; 9
 526:	90 e0       	ldi	r25, 0x00	; 0
 528:	6b c0       	rjmp	.+214    	; 0x600 <__stack+0x1a1>
				else
				if ((mDataBuff[4]==mInitDeviceID[0])&&(mDataBuff[5]==mRND[0])&&(mDataBuff[6]==mRND[1]))
 52a:	20 91 da 00 	lds	r18, 0x00DA
 52e:	30 91 db 00 	lds	r19, 0x00DB
 532:	80 91 c0 00 	lds	r24, 0x00C0
 536:	90 91 c1 00 	lds	r25, 0x00C1
 53a:	28 17       	cp	r18, r24
 53c:	39 07       	cpc	r19, r25
 53e:	c9 f4       	brne	.+50     	; 0x572 <__stack+0x113>
 540:	20 91 dc 00 	lds	r18, 0x00DC
 544:	30 91 dd 00 	lds	r19, 0x00DD
 548:	80 91 a0 00 	lds	r24, 0x00A0
 54c:	90 91 a1 00 	lds	r25, 0x00A1
 550:	28 17       	cp	r18, r24
 552:	39 07       	cpc	r19, r25
 554:	71 f4       	brne	.+28     	; 0x572 <__stack+0x113>
 556:	20 91 de 00 	lds	r18, 0x00DE
 55a:	30 91 df 00 	lds	r19, 0x00DF
 55e:	80 91 a2 00 	lds	r24, 0x00A2
 562:	90 91 a3 00 	lds	r25, 0x00A3
 566:	28 17       	cp	r18, r24
 568:	39 07       	cpc	r19, r25
 56a:	19 f4       	brne	.+6      	; 0x572 <__stack+0x113>
					mCmdFound = mMelCmdRND; 
 56c:	8a e0       	ldi	r24, 0x0A	; 10
 56e:	90 e0       	ldi	r25, 0x00	; 0
 570:	47 c0       	rjmp	.+142    	; 0x600 <__stack+0x1a1>
				else
				if ((mDataBuff[4]==mInitDeviceID[0])&&(mDataBuff[5]==mFF[0])&&(mDataBuff[6]==mFF[1]))
 572:	20 91 da 00 	lds	r18, 0x00DA
 576:	30 91 db 00 	lds	r19, 0x00DB
 57a:	80 91 c0 00 	lds	r24, 0x00C0
 57e:	90 91 c1 00 	lds	r25, 0x00C1
 582:	28 17       	cp	r18, r24
 584:	39 07       	cpc	r19, r25
 586:	c9 f4       	brne	.+50     	; 0x5ba <__stack+0x15b>
 588:	20 91 dc 00 	lds	r18, 0x00DC
 58c:	30 91 dd 00 	lds	r19, 0x00DD
 590:	80 91 a4 00 	lds	r24, 0x00A4
 594:	90 91 a5 00 	lds	r25, 0x00A5
 598:	28 17       	cp	r18, r24
 59a:	39 07       	cpc	r19, r25
 59c:	71 f4       	brne	.+28     	; 0x5ba <__stack+0x15b>
 59e:	20 91 de 00 	lds	r18, 0x00DE
 5a2:	30 91 df 00 	lds	r19, 0x00DF
 5a6:	80 91 a6 00 	lds	r24, 0x00A6
 5aa:	90 91 a7 00 	lds	r25, 0x00A7
 5ae:	28 17       	cp	r18, r24
 5b0:	39 07       	cpc	r19, r25
 5b2:	19 f4       	brne	.+6      	; 0x5ba <__stack+0x15b>
					mCmdFound = mMelCmdFF; 
 5b4:	8b e0       	ldi	r24, 0x0B	; 11
 5b6:	90 e0       	ldi	r25, 0x00	; 0
 5b8:	23 c0       	rjmp	.+70     	; 0x600 <__stack+0x1a1>
				else
				if ((mDataBuff[4]==mInitDeviceID[0])&&(mDataBuff[5]==mFR[0])&&(mDataBuff[6]==mFR[1]))
 5ba:	20 91 da 00 	lds	r18, 0x00DA
 5be:	30 91 db 00 	lds	r19, 0x00DB
 5c2:	80 91 c0 00 	lds	r24, 0x00C0
 5c6:	90 91 c1 00 	lds	r25, 0x00C1
 5ca:	28 17       	cp	r18, r24
 5cc:	39 07       	cpc	r19, r25
 5ce:	e1 f4       	brne	.+56     	; 0x608 <__stack+0x1a9>
 5d0:	20 91 dc 00 	lds	r18, 0x00DC
 5d4:	30 91 dd 00 	lds	r19, 0x00DD
 5d8:	80 91 a8 00 	lds	r24, 0x00A8
 5dc:	90 91 a9 00 	lds	r25, 0x00A9
 5e0:	28 17       	cp	r18, r24
 5e2:	39 07       	cpc	r19, r25
 5e4:	89 f4       	brne	.+34     	; 0x608 <__stack+0x1a9>
 5e6:	20 91 de 00 	lds	r18, 0x00DE
 5ea:	30 91 df 00 	lds	r19, 0x00DF
 5ee:	80 91 aa 00 	lds	r24, 0x00AA
 5f2:	90 91 ab 00 	lds	r25, 0x00AB
 5f6:	28 17       	cp	r18, r24
 5f8:	39 07       	cpc	r19, r25
 5fa:	31 f4       	brne	.+12     	; 0x608 <__stack+0x1a9>
					mCmdFound = mMelCmdFR; 
 5fc:	8c e0       	ldi	r24, 0x0C	; 12
 5fe:	90 e0       	ldi	r25, 0x00	; 0
 600:	90 93 e9 00 	sts	0x00E9, r25
 604:	80 93 e8 00 	sts	0x00E8, r24

		default: break;
	} // end switch mWaiting

#ifndef LOGONLY // only sniffer, don't send any commands!
	switch (mCmdFound) // process commands
 608:	40 91 e8 00 	lds	r20, 0x00E8
 60c:	50 91 e9 00 	lds	r21, 0x00E9
 610:	47 30       	cpi	r20, 0x07	; 7
 612:	51 05       	cpc	r21, r1
 614:	09 f4       	brne	.+2      	; 0x618 <__stack+0x1b9>
 616:	73 c0       	rjmp	.+230    	; 0x6fe <__stack+0x29f>
 618:	48 30       	cpi	r20, 0x08	; 8
 61a:	51 05       	cpc	r21, r1
 61c:	b8 f4       	brcc	.+46     	; 0x64c <__stack+0x1ed>
 61e:	43 30       	cpi	r20, 0x03	; 3
 620:	51 05       	cpc	r21, r1
 622:	09 f4       	brne	.+2      	; 0x626 <__stack+0x1c7>
 624:	da c0       	rjmp	.+436    	; 0x7da <__stack+0x37b>
 626:	44 30       	cpi	r20, 0x04	; 4
 628:	51 05       	cpc	r21, r1
 62a:	40 f4       	brcc	.+16     	; 0x63c <__stack+0x1dd>
 62c:	41 30       	cpi	r20, 0x01	; 1
 62e:	51 05       	cpc	r21, r1
 630:	31 f1       	breq	.+76     	; 0x67e <__stack+0x21f>
 632:	42 30       	cpi	r20, 0x02	; 2
 634:	51 05       	cpc	r21, r1
 636:	09 f0       	breq	.+2      	; 0x63a <__stack+0x1db>
 638:	02 c1       	rjmp	.+516    	; 0x83e <__stack+0x3df>
 63a:	a9 c0       	rjmp	.+338    	; 0x78e <__stack+0x32f>
 63c:	45 30       	cpi	r20, 0x05	; 5
 63e:	51 05       	cpc	r21, r1
 640:	d9 f1       	breq	.+118    	; 0x6b8 <__stack+0x259>
 642:	46 30       	cpi	r20, 0x06	; 6
 644:	51 05       	cpc	r21, r1
 646:	09 f0       	breq	.+2      	; 0x64a <__stack+0x1eb>
 648:	fa c0       	rjmp	.+500    	; 0x83e <__stack+0x3df>
 64a:	4f c0       	rjmp	.+158    	; 0x6ea <__stack+0x28b>
 64c:	4a 30       	cpi	r20, 0x0A	; 10
 64e:	51 05       	cpc	r21, r1
 650:	09 f4       	brne	.+2      	; 0x654 <__stack+0x1f5>
 652:	7d c0       	rjmp	.+250    	; 0x74e <__stack+0x2ef>
 654:	4b 30       	cpi	r20, 0x0B	; 11
 656:	51 05       	cpc	r21, r1
 658:	48 f4       	brcc	.+18     	; 0x66c <__stack+0x20d>
 65a:	48 30       	cpi	r20, 0x08	; 8
 65c:	51 05       	cpc	r21, r1
 65e:	09 f4       	brne	.+2      	; 0x662 <__stack+0x203>
 660:	58 c0       	rjmp	.+176    	; 0x712 <__stack+0x2b3>
 662:	49 30       	cpi	r20, 0x09	; 9
 664:	51 05       	cpc	r21, r1
 666:	09 f0       	breq	.+2      	; 0x66a <__stack+0x20b>
 668:	ea c0       	rjmp	.+468    	; 0x83e <__stack+0x3df>
 66a:	5d c0       	rjmp	.+186    	; 0x726 <__stack+0x2c7>
 66c:	4b 30       	cpi	r20, 0x0B	; 11
 66e:	51 05       	cpc	r21, r1
 670:	09 f4       	brne	.+2      	; 0x674 <__stack+0x215>
 672:	6d c0       	rjmp	.+218    	; 0x74e <__stack+0x2ef>
 674:	4c 30       	cpi	r20, 0x0C	; 12
 676:	51 05       	cpc	r21, r1
 678:	09 f0       	breq	.+2      	; 0x67c <__stack+0x21d>
 67a:	e1 c0       	rjmp	.+450    	; 0x83e <__stack+0x3df>
 67c:	6d c0       	rjmp	.+218    	; 0x758 <__stack+0x2f9>
	{
		case (mWaiting): break; // ops, just quit!
		

		case (mMelCmdInit):
			if (mDataIn == mInitDeviceID[0]) // wait for Melbus device id
 67e:	20 91 e0 00 	lds	r18, 0x00E0
 682:	30 91 e1 00 	lds	r19, 0x00E1
 686:	80 91 c0 00 	lds	r24, 0x00C0
 68a:	90 91 c1 00 	lds	r25, 0x00C1
 68e:	28 17       	cp	r18, r24
 690:	39 07       	cpc	r19, r25
 692:	09 f0       	breq	.+2      	; 0x696 <__stack+0x237>
 694:	d4 c0       	rjmp	.+424    	; 0x83e <__stack+0x3df>
			{
					mState = mState_SEND;
 696:	50 93 e7 00 	sts	0x00E7, r21
 69a:	40 93 e6 00 	sts	0x00E6, r20
					mDataOut = mInitDeviceID[0]; // send device id
 69e:	80 91 c0 00 	lds	r24, 0x00C0
 6a2:	90 91 c1 00 	lds	r25, 0x00C1
 6a6:	90 93 e3 00 	sts	0x00E3, r25
 6aa:	80 93 e2 00 	sts	0x00E2, r24
					
				
						mCmdFound = mWaiting; // return to cmd search mode	
 6ae:	10 92 e9 00 	sts	0x00E9, r1
 6b2:	10 92 e8 00 	sts	0x00E8, r1
 6b6:	c1 c0       	rjmp	.+386    	; 0x83a <__stack+0x3db>
				
			} 		
		 break;

		case (mMelCmdPwrD):
					mState = mState_SEND;
 6b8:	81 e0       	ldi	r24, 0x01	; 1
 6ba:	90 e0       	ldi	r25, 0x00	; 0
 6bc:	90 93 e7 00 	sts	0x00E7, r25
 6c0:	80 93 e6 00 	sts	0x00E6, r24
					mDataOut = 0x00; // respond to powerdown;
 6c4:	10 92 e3 00 	sts	0x00E3, r1
 6c8:	10 92 e2 00 	sts	0x00E2, r1
					mCmdFound = mWaiting; // return to cmd search mode	
 6cc:	10 92 e9 00 	sts	0x00E9, r1
 6d0:	10 92 e8 00 	sts	0x00E8, r1
					mPlayInfo[1]=0x02; // STOP
 6d4:	82 e0       	ldi	r24, 0x02	; 2
 6d6:	90 e0       	ldi	r25, 0x00	; 0
 6d8:	90 93 af 00 	sts	0x00AF, r25
 6dc:	80 93 ae 00 	sts	0x00AE, r24
					mPlayInfo[8]=0x02; // STOP
 6e0:	90 93 bd 00 	sts	0x00BD, r25
 6e4:	80 93 bc 00 	sts	0x00BC, r24
 6e8:	a8 c0       	rjmp	.+336    	; 0x83a <__stack+0x3db>
					setoutput_mdata(); // PD2 output
				
		break;
		
		case (mMelCmdNext):
					mCmdFound = mWaiting; // return to cmd search mode	
 6ea:	10 92 e9 00 	sts	0x00E9, r1
 6ee:	10 92 e8 00 	sts	0x00E8, r1
					mPlayInfo[5]++; // 5
 6f2:	80 91 b6 00 	lds	r24, 0x00B6
 6f6:	90 91 b7 00 	lds	r25, 0x00B7
 6fa:	01 96       	adiw	r24, 0x01	; 1
 6fc:	23 c0       	rjmp	.+70     	; 0x744 <__stack+0x2e5>
		 break;
		case (mMelCmdPrev):
					mCmdFound = mWaiting; // return to cmd search mode	
 6fe:	10 92 e9 00 	sts	0x00E9, r1
 702:	10 92 e8 00 	sts	0x00E8, r1
					mPlayInfo[5]--; // 5
 706:	80 91 b6 00 	lds	r24, 0x00B6
 70a:	90 91 b7 00 	lds	r25, 0x00B7
 70e:	01 97       	sbiw	r24, 0x01	; 1
 710:	19 c0       	rjmp	.+50     	; 0x744 <__stack+0x2e5>
		 break;
		case (mMelCmdDinc):
					mCmdFound = mWaiting; // return to cmd search mode	
 712:	10 92 e9 00 	sts	0x00E9, r1
 716:	10 92 e8 00 	sts	0x00E8, r1
					mPlayInfo[3]++;
 71a:	80 91 b2 00 	lds	r24, 0x00B2
 71e:	90 91 b3 00 	lds	r25, 0x00B3
 722:	01 96       	adiw	r24, 0x01	; 1
 724:	09 c0       	rjmp	.+18     	; 0x738 <__stack+0x2d9>
					mPlayInfo[5]=0x01;
		 break;
		case (mMelCmdDdec):
					mCmdFound = mWaiting; // return to cmd search mode	
 726:	10 92 e9 00 	sts	0x00E9, r1
 72a:	10 92 e8 00 	sts	0x00E8, r1
					mPlayInfo[3]--;
 72e:	80 91 b2 00 	lds	r24, 0x00B2
 732:	90 91 b3 00 	lds	r25, 0x00B3
 736:	01 97       	sbiw	r24, 0x01	; 1
 738:	90 93 b3 00 	sts	0x00B3, r25
 73c:	80 93 b2 00 	sts	0x00B2, r24
					mPlayInfo[5]=0x01;
 740:	81 e0       	ldi	r24, 0x01	; 1
 742:	90 e0       	ldi	r25, 0x00	; 0
 744:	90 93 b7 00 	sts	0x00B7, r25
 748:	80 93 b6 00 	sts	0x00B6, r24
 74c:	78 c0       	rjmp	.+240    	; 0x83e <__stack+0x3df>
		 break;
 		case (mMelCmdRND):
					mCmdFound = mWaiting; // return to cmd search mode	
		 break;
 		case (mMelCmdFF):
					mCmdFound = mWaiting; // return to cmd search mode	
 74e:	10 92 e9 00 	sts	0x00E9, r1
 752:	10 92 e8 00 	sts	0x00E8, r1
 756:	73 c0       	rjmp	.+230    	; 0x83e <__stack+0x3df>
		 break;
 		case (mMelCmdFR):
					mState = mState_SEND;
 758:	81 e0       	ldi	r24, 0x01	; 1
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	90 93 e7 00 	sts	0x00E7, r25
 760:	80 93 e6 00 	sts	0x00E6, r24
					mDataOut = 0x00; // respond to powerup / fastforward
 764:	10 92 e3 00 	sts	0x00E3, r1
 768:	10 92 e2 00 	sts	0x00E2, r1
					mCmdFound = mWaiting; // return to cmd search mode	
 76c:	10 92 e9 00 	sts	0x00E9, r1
 770:	10 92 e8 00 	sts	0x00E8, r1
 	TCCR1B|=(1<<ICES1); 	// Rising-Edge Triggered
}

void setoutput_mdata(void)
{
	DDRD |= (1<<PIND2); // PD2 output
 774:	8a 9a       	sbi	0x11, 2	; 17
	PORTD |= (1 << PD2);
 776:	92 9a       	sbi	0x12, 2	; 18
					mState = mState_SEND;
					mDataOut = 0x00; // respond to powerup / fastforward
					mCmdFound = mWaiting; // return to cmd search mode	
					setoutput_mdata(); // PD2 output
		
					mPlayInfo[8]=0x08; // Enter PLAY MODE!
 778:	88 e0       	ldi	r24, 0x08	; 8
 77a:	90 e0       	ldi	r25, 0x00	; 0
 77c:	90 93 bd 00 	sts	0x00BD, r25
 780:	80 93 bc 00 	sts	0x00BC, r24
					mPlayInfo[1]=0x08;
 784:	90 93 af 00 	sts	0x00AF, r25
 788:	80 93 ae 00 	sts	0x00AE, r24
 78c:	58 c0       	rjmp	.+176    	; 0x83e <__stack+0x3df>
		 break;

		case (mMelCmdPlay):
					mState = mState_SEND;
 78e:	81 e0       	ldi	r24, 0x01	; 1
 790:	90 e0       	ldi	r25, 0x00	; 0
 792:	90 93 e7 00 	sts	0x00E7, r25
 796:	80 93 e6 00 	sts	0x00E6, r24
					mDataOut = mPlayInfo[mByteC]; // send cmd answer 
 79a:	e0 91 e4 00 	lds	r30, 0x00E4
 79e:	f0 91 e5 00 	lds	r31, 0x00E5
 7a2:	ee 0f       	add	r30, r30
 7a4:	ff 1f       	adc	r31, r31
 7a6:	e4 55       	subi	r30, 0x54	; 84
 7a8:	ff 4f       	sbci	r31, 0xFF	; 255
 7aa:	80 81       	ld	r24, Z
 7ac:	91 81       	ldd	r25, Z+1	; 0x01
 7ae:	90 93 e3 00 	sts	0x00E3, r25
 7b2:	80 93 e2 00 	sts	0x00E2, r24
					mByteC++;
 7b6:	80 91 e4 00 	lds	r24, 0x00E4
 7ba:	90 91 e5 00 	lds	r25, 0x00E5
 7be:	01 96       	adiw	r24, 0x01	; 1
 7c0:	90 93 e5 00 	sts	0x00E5, r25
 7c4:	80 93 e4 00 	sts	0x00E4, r24
					if (mByteC > mPlayInfoLen)
 7c8:	20 91 e4 00 	lds	r18, 0x00E4
 7cc:	30 91 e5 00 	lds	r19, 0x00E5
 7d0:	80 91 be 00 	lds	r24, 0x00BE
 7d4:	90 91 bf 00 	lds	r25, 0x00BF
 7d8:	25 c0       	rjmp	.+74     	; 0x824 <__stack+0x3c5>
					}
					setoutput_mdata(); // PD2 output
		 break;

		 case (mMelCmdInfo):
					mState = mState_SEND;
 7da:	81 e0       	ldi	r24, 0x01	; 1
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	90 93 e7 00 	sts	0x00E7, r25
 7e2:	80 93 e6 00 	sts	0x00E6, r24
					mDataOut = mCartInfo[mByteC]; // send cmd answer 
 7e6:	e0 91 e4 00 	lds	r30, 0x00E4
 7ea:	f0 91 e5 00 	lds	r31, 0x00E5
 7ee:	ee 0f       	add	r30, r30
 7f0:	ff 1f       	adc	r31, r31
 7f2:	ee 53       	subi	r30, 0x3E	; 62
 7f4:	ff 4f       	sbci	r31, 0xFF	; 255
 7f6:	80 81       	ld	r24, Z
 7f8:	91 81       	ldd	r25, Z+1	; 0x01
 7fa:	90 93 e3 00 	sts	0x00E3, r25
 7fe:	80 93 e2 00 	sts	0x00E2, r24
					mByteC++;
 802:	80 91 e4 00 	lds	r24, 0x00E4
 806:	90 91 e5 00 	lds	r25, 0x00E5
 80a:	01 96       	adiw	r24, 0x01	; 1
 80c:	90 93 e5 00 	sts	0x00E5, r25
 810:	80 93 e4 00 	sts	0x00E4, r24
					if (mByteC > mCartInfoLen)
 814:	20 91 e4 00 	lds	r18, 0x00E4
 818:	30 91 e5 00 	lds	r19, 0x00E5
 81c:	80 91 ce 00 	lds	r24, 0x00CE
 820:	90 91 cf 00 	lds	r25, 0x00CF
 824:	82 17       	cp	r24, r18
 826:	93 07       	cpc	r25, r19
 828:	40 f4       	brcc	.+16     	; 0x83a <__stack+0x3db>
					{
						mCmdFound = mWaiting; // return to cmd search mode
 82a:	10 92 e9 00 	sts	0x00E9, r1
 82e:	10 92 e8 00 	sts	0x00E8, r1
						mByteC=0;
 832:	10 92 e5 00 	sts	0x00E5, r1
 836:	10 92 e4 00 	sts	0x00E4, r1
 	TCCR1B|=(1<<ICES1); 	// Rising-Edge Triggered
}

void setoutput_mdata(void)
{
	DDRD |= (1<<PIND2); // PD2 output
 83a:	8a 9a       	sbi	0x11, 2	; 17
	PORTD |= (1 << PD2);
 83c:	92 9a       	sbi	0x12, 2	; 18

			default: break;
	}
#endif
	
}
 83e:	ff 91       	pop	r31
 840:	ef 91       	pop	r30
 842:	9f 91       	pop	r25
 844:	8f 91       	pop	r24
 846:	5f 91       	pop	r21
 848:	4f 91       	pop	r20
 84a:	3f 91       	pop	r19
 84c:	2f 91       	pop	r18
 84e:	0f 90       	pop	r0
 850:	0f be       	out	0x3f, r0	; 63
 852:	0f 90       	pop	r0
 854:	1f 90       	pop	r1
 856:	18 95       	reti

00000858 <__vector_5>:

ISR(TIMER1_CAPT_vect)
{
 858:	1f 92       	push	r1
 85a:	0f 92       	push	r0
 85c:	0f b6       	in	r0, 0x3f	; 63
 85e:	0f 92       	push	r0
 860:	11 24       	eor	r1, r1
 862:	2f 93       	push	r18
 864:	3f 93       	push	r19
 866:	4f 93       	push	r20
 868:	5f 93       	push	r21
 86a:	8f 93       	push	r24
 86c:	9f 93       	push	r25

	TCNT1 = 0xFF9C; // 50uS   // 0xFF38;  // ovf at 100uS 
 86e:	8c e9       	ldi	r24, 0x9C	; 156
 870:	9f ef       	ldi	r25, 0xFF	; 255
 872:	9d bd       	out	0x2d, r25	; 45
 874:	8c bd       	out	0x2c, r24	; 44
	TCCR1B|=(1<<CS11);
 876:	8e b5       	in	r24, 0x2e	; 46
 878:	82 60       	ori	r24, 0x02	; 2
 87a:	8e bd       	out	0x2e, r24	; 46

	// read DATA on rising CLOCK pulse
	if (PIND & (1<<PIND2))  // if Melbus DATA is logical 1
 87c:	82 9b       	sbis	0x10, 2	; 16
 87e:	12 c0       	rjmp	.+36     	; 0x8a4 <__vector_5+0x4c>
		mDataIn |= (1 << mClock); // set bit to 1
 880:	40 91 e0 00 	lds	r20, 0x00E0
 884:	50 91 e1 00 	lds	r21, 0x00E1
 888:	20 91 d0 00 	lds	r18, 0x00D0
 88c:	30 91 d1 00 	lds	r19, 0x00D1
 890:	81 e0       	ldi	r24, 0x01	; 1
 892:	90 e0       	ldi	r25, 0x00	; 0
 894:	02 c0       	rjmp	.+4      	; 0x89a <__vector_5+0x42>
 896:	88 0f       	add	r24, r24
 898:	99 1f       	adc	r25, r25
 89a:	2a 95       	dec	r18
 89c:	e2 f7       	brpl	.-8      	; 0x896 <__vector_5+0x3e>
 89e:	84 2b       	or	r24, r20
 8a0:	95 2b       	or	r25, r21
 8a2:	13 c0       	rjmp	.+38     	; 0x8ca <__vector_5+0x72>
	else
		mDataIn &= ~(1 << mClock); // set bit to 0
 8a4:	40 91 e0 00 	lds	r20, 0x00E0
 8a8:	50 91 e1 00 	lds	r21, 0x00E1
 8ac:	20 91 d0 00 	lds	r18, 0x00D0
 8b0:	30 91 d1 00 	lds	r19, 0x00D1
 8b4:	81 e0       	ldi	r24, 0x01	; 1
 8b6:	90 e0       	ldi	r25, 0x00	; 0
 8b8:	02 c0       	rjmp	.+4      	; 0x8be <__vector_5+0x66>
 8ba:	88 0f       	add	r24, r24
 8bc:	99 1f       	adc	r25, r25
 8be:	2a 95       	dec	r18
 8c0:	e2 f7       	brpl	.-8      	; 0x8ba <__vector_5+0x62>
 8c2:	80 95       	com	r24
 8c4:	90 95       	com	r25
 8c6:	84 23       	and	r24, r20
 8c8:	95 23       	and	r25, r21
 8ca:	90 93 e1 00 	sts	0x00E1, r25
 8ce:	80 93 e0 00 	sts	0x00E0, r24

	mClock--;
 8d2:	80 91 d0 00 	lds	r24, 0x00D0
 8d6:	90 91 d1 00 	lds	r25, 0x00D1
 8da:	01 97       	sbiw	r24, 0x01	; 1
 8dc:	90 93 d1 00 	sts	0x00D1, r25
 8e0:	80 93 d0 00 	sts	0x00D0, r24
	
}
 8e4:	9f 91       	pop	r25
 8e6:	8f 91       	pop	r24
 8e8:	5f 91       	pop	r21
 8ea:	4f 91       	pop	r20
 8ec:	3f 91       	pop	r19
 8ee:	2f 91       	pop	r18
 8f0:	0f 90       	pop	r0
 8f2:	0f be       	out	0x3f, r0	; 63
 8f4:	0f 90       	pop	r0
 8f6:	1f 90       	pop	r1
 8f8:	18 95       	reti

000008fa <__vector_1>:

// External Interrupt 0 ISR  == DATA ==
SIGNAL(SIG_INTERRUPT0)
{
 8fa:	1f 92       	push	r1
 8fc:	0f 92       	push	r0
 8fe:	0f b6       	in	r0, 0x3f	; 63
 900:	0f 92       	push	r0
 902:	11 24       	eor	r1, r1

}
 904:	0f 90       	pop	r0
 906:	0f be       	out	0x3f, r0	; 63
 908:	0f 90       	pop	r0
 90a:	1f 90       	pop	r1
 90c:	18 95       	reti

0000090e <__vector_2>:


// External Interrupt 1 ISR  == CLOCK ==
SIGNAL(SIG_INTERRUPT1)
{
 90e:	1f 92       	push	r1
 910:	0f 92       	push	r0
 912:	0f b6       	in	r0, 0x3f	; 63
 914:	0f 92       	push	r0
 916:	11 24       	eor	r1, r1
 918:	2f 93       	push	r18
 91a:	3f 93       	push	r19
 91c:	4f 93       	push	r20
 91e:	5f 93       	push	r21
 920:	8f 93       	push	r24
 922:	9f 93       	push	r25
	if (mState == mState_SEND)
 924:	40 91 e6 00 	lds	r20, 0x00E6
 928:	50 91 e7 00 	lds	r21, 0x00E7
 92c:	41 30       	cpi	r20, 0x01	; 1
 92e:	51 05       	cpc	r21, r1
 930:	a1 f4       	brne	.+40     	; 0x95a <__vector_2+0x4c>
	{
	  	if (( mDataOut & (1 << mClock) ))  // if Melbus DATA is logical 1    
 932:	20 91 e2 00 	lds	r18, 0x00E2
 936:	30 91 e3 00 	lds	r19, 0x00E3
 93a:	80 91 d0 00 	lds	r24, 0x00D0
 93e:	90 91 d1 00 	lds	r25, 0x00D1
 942:	02 c0       	rjmp	.+4      	; 0x948 <__vector_2+0x3a>
 944:	44 0f       	add	r20, r20
 946:	55 1f       	adc	r21, r21
 948:	8a 95       	dec	r24
 94a:	e2 f7       	brpl	.-8      	; 0x944 <__vector_2+0x36>
 94c:	42 23       	and	r20, r18
 94e:	53 23       	and	r21, r19
 950:	45 2b       	or	r20, r21
 952:	11 f0       	breq	.+4      	; 0x958 <__vector_2+0x4a>
			PORTD |= (1 << PD2); // set 1
 954:	92 9a       	sbi	0x12, 2	; 18
 956:	01 c0       	rjmp	.+2      	; 0x95a <__vector_2+0x4c>
		else
			PORTD &= ~(1 << PD2); // set  0
 958:	92 98       	cbi	0x12, 2	; 18
	} // end mState_SEND
}
 95a:	9f 91       	pop	r25
 95c:	8f 91       	pop	r24
 95e:	5f 91       	pop	r21
 960:	4f 91       	pop	r20
 962:	3f 91       	pop	r19
 964:	2f 91       	pop	r18
 966:	0f 90       	pop	r0
 968:	0f be       	out	0x3f, r0	; 63
 96a:	0f 90       	pop	r0
 96c:	1f 90       	pop	r1
 96e:	18 95       	reti

00000970 <main>:
volatile unsigned int mDataBuff[7] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};


void init_extint0(void)
{
	GICR |= 1<<INT0; 	// Enable INT0 External Interrupt
 970:	8b b7       	in	r24, 0x3b	; 59
 972:	80 64       	ori	r24, 0x40	; 64
 974:	8b bf       	out	0x3b, r24	; 59
	MCUCR |= 1<<ISC01; 	// Falling-Edge Triggered INT0
 976:	85 b7       	in	r24, 0x35	; 53
 978:	82 60       	ori	r24, 0x02	; 2
 97a:	85 bf       	out	0x35, r24	; 53
}


void init_extint1(void)
{
	GICR |= 1<<INT1; // Enable INT1 External Interrupt
 97c:	8b b7       	in	r24, 0x3b	; 59
 97e:	80 68       	ori	r24, 0x80	; 128
 980:	8b bf       	out	0x3b, r24	; 59
	MCUCR |= 1<<ISC11; // Falling-Edge Triggered INT0
 982:	85 b7       	in	r24, 0x35	; 53
 984:	88 60       	ori	r24, 0x08	; 8
 986:	85 bf       	out	0x35, r24	; 53
}

void init_timer(void)
{
	TIMSK|=(1<<TICIE1)|(1<<TOIE1);  // T1 Interrupt Capture and Timer1 Overflow
 988:	89 b7       	in	r24, 0x39	; 57
 98a:	84 62       	ori	r24, 0x24	; 36
 98c:	89 bf       	out	0x39, r24	; 57
 	TCCR1B|=(1<<ICES1); 	// Rising-Edge Triggered
 98e:	8e b5       	in	r24, 0x2e	; 46
 990:	80 64       	ori	r24, 0x40	; 64
 992:	8e bd       	out	0x2e, r24	; 46
#endif
	init_timer(); // init bit timer


	// setup Melbus pins!
	DDRD &= ~(1<<PIND2); // input
 994:	8a 98       	cbi	0x11, 2	; 17
	PORTD |= (1<<PD2); // enable pull-up
 996:	92 9a       	sbi	0x12, 2	; 18
	DDRD &= ~(1<<PIND3); // input
 998:	8b 98       	cbi	0x11, 3	; 17
	PORTD |= (1<<PD3); // enable pull-up
 99a:	93 9a       	sbi	0x12, 3	; 18
	DDRC &= ~(1<<PINC0); // input
 99c:	a0 98       	cbi	0x14, 0	; 20
	PORTC |= (1<<PC0); // enable pull-up
 99e:	a8 9a       	sbi	0x15, 0	; 21

	// Enable Interrupts
	sei();
 9a0:	78 94       	sei

	// set mBusy at powerup to notify HU !
	DDRC |= (1<<PINC0); // output
 9a2:	a0 9a       	sbi	0x14, 0	; 20
	PORTC &= ~(1<<PC0); // logical 0
 9a4:	a8 98       	cbi	0x15, 0	; 21
 9a6:	80 e1       	ldi	r24, 0x10	; 16
 9a8:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 9aa:	20 e9       	ldi	r18, 0x90	; 144
 9ac:	31 e0       	ldi	r19, 0x01	; 1
 9ae:	f9 01       	movw	r30, r18
 9b0:	31 97       	sbiw	r30, 0x01	; 1
 9b2:	f1 f7       	brne	.-4      	; 0x9b0 <main+0x40>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 9b4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 9b6:	d9 f7       	brne	.-10     	; 0x9ae <main+0x3e>
	_delay_ms(1000); // 2secs seems to do the trick, a breef ERROR message might show up!
	DDRC &= ~(1<<PINC0); // input
 9b8:	a0 98       	cbi	0x14, 0	; 20
	PORTC |= (1<<PC0); // enable pull-up
 9ba:	a8 9a       	sbi	0x15, 0	; 21
 9bc:	ff cf       	rjmp	.-2      	; 0x9bc <main+0x4c>

000009be <_exit>:
 9be:	f8 94       	cli

000009c0 <__stop_program>:
 9c0:	ff cf       	rjmp	.-2      	; 0x9c0 <__stop_program>
